# HG changeset patch
# User hohnsdwi@uw.edu
# Date 1370889305 25200
#      Mon Jun 10 11:35:05 2013 -0700
# Node ID 8d94ceb4f6926a521971bcc4947ffa32b120b882
# Parent  683c8aec254113e20a38b25f90c52b366ced7de1
Cleaned up documentation for logicparser.py

diff --git a/sage/logic/logicparser.py b/sage/logic/logicparser.py
--- a/sage/logic/logicparser.py
+++ b/sage/logic/logicparser.py
@@ -1,11 +1,15 @@
 r"""
-Module that creates and modifies parse trees of well formed
+LogicParser
+
+Module that creates and modifies parse trees of well formed 
 boolean formulas.
 
 AUTHORS:
-    -- Chris Gorecki
 
-EXAMPLES:
+- Chris Gorecki
+
+EXAMPLES::
+
     sage: import sage.logic.logicparser as logicparser
     sage: s = 'a|b&c'
     sage: t = logicparser.parse(s)
@@ -21,15 +25,18 @@
 
 def parse(s):
     r"""
-    This function produces a parse tree from a boolean formula s.
-
+    This function produces a parse tree from a boolean formula ``s``.
+    
     INPUT:
-        s -- a string containing a boolean formula.
-
+	
+    - ``s`` -- a string containing a boolean formula.
+            
     OUTPUT:
-        Returns the tuple (parse tree of s, variables in s).
-
-    EXAMPLES:
+	
+    - Returns the tuple (parse tree of ``s``, variables in ``s``).
+    
+    EXAMPLES::
+	
         sage: import sage.logic.logicparser as logicparser
         sage: s = 'a|b&c'
         sage: t = logicparser.parse(s)
@@ -41,31 +48,34 @@
         #special case of tree == single variable
     if(type(tree) is StringType and len([tree]) == 1):
                 return ['&', tree, tree], vars_order
-    return tree, vars_order
+    return tree, vars_order    
 
 def tokenize(s):
     r"""
-    This function produces a string of tokens from s.
-
+    This function produces a string of tokens from ``s``.
+    
     INPUT:
-        s -- a string containing a boolean formula.
-
-    OUTPUT:
-        Returns a tuple consisting of (tokens in s, variables in s).
-
-    EXAMPLES:
+	
+    - ``s`` -- a string containing a boolean formula.
+            
+    OUTPUT:        
+	
+    - Returns a tuple consisting of (tokens in ``s``, variables in ``s``).
+   
+    EXAMPLES::
+	
         sage: import sage.logic.logicparser as logicparser
         sage: s = 'a|b&c'
         sage: t = logicparser.tokenize(s)
         sage: t
-        (['(', 'a', '|', 'b', '&', 'c', ')'], ['a', 'b', 'c'])
+        (['(', 'a', '|', 'b', '&', 'c', ')'], ['a', 'b', 'c'])        
     """
-    i = 0
+    i = 0  
     toks = ['(']
     vars_order = []
-
-    while(i < len(s)):
-        tok = ""
+    
+    while(i < len(s)):        
+        tok = ""     
         skip = valid = 1
         if(s[i] in '()~&|^'):
             tok = s[i]
@@ -84,42 +94,45 @@
             if(s[i] == ' '):
                 i += 1
                 continue
-
+             
             while(i < len(s) and s[i] not in __symbols and s[i] != ' '):
                 tok += s[i]
                 i += 1
-
+             
             if(len(tok) > 0):
-                if(tok[0] not in string.letters):
+                if(tok[0] not in string.letters): 
                     valid = 0
                 for c in tok:
                     if(c not in string.letters and c not in string.digits and c != '_'):
                         valid = 0
-
-            if(valid == 1):
+                  
+            if(valid == 1): 
                 toks.append(tok)
                 if(tok not in vars_order):
                     vars_order.append(tok)
             else:
                 msg = 'invalid variable name ' + tok
                 msg += ": identifiers must begin with a letter and contain only "
-                msg += "alphanumerics and underscores"
+                msg += "alphanumerics and underscores" 
                 raise NameError, msg
-
+        
     toks.append(')')
     return toks, vars_order
 
 def tree_parse(toks):
     r"""
-    This function produces a parse tree from the tokens in toks.
-
+    This function produces a parse tree from the tokens in ``toks``.
+    
     INPUT:
-        toks -- a list of tokens.
-
+	
+    - ``toks`` -- a list of tokens.
+            
     OUTPUT:
-        Returns a parse tree of the tokens toks.
-
-    EXAMPLES:
+	
+    - Returns a parse tree of the tokens toks.
+   
+    EXAMPLES::
+	
         sage: import sage.logic.logicparser as logicparser
         sage: t = ['(', 'a', '|', 'b', '&', 'c', ')']
         sage: logicparser.tree_parse(t)
@@ -132,32 +145,35 @@
             lrtoks = []
             while(tok != '('):
                 tok = stack.pop()
-                lrtoks.insert(0, tok)
+                lrtoks.insert(0, tok) 
             branch = parse_ltor(lrtoks[1:-1])
             stack.append(branch)
-    return stack[0]
-
+    return stack[0]     
+        
 def parse_ltor(toks, n = 0):
     r"""
-    This function produces a parse tree from the tokens in toks under
-    the precondition that each token in toks is atomic.
-
+    This function produces a parse tree from the tokens in ``toks`` under
+    the precondition that each token in ``toks`` is atomic.
+    
     INPUT:
-        toks -- a list of tokens.
-        n -- an integer representing which order of operations
-             are occurring.
-
+    
+    - ``toks`` -- a list of tokens.
+    - ``n`` -- an integer representing which order of operations
+	  are occurring.
+            
     OUTPUT:
-        Returns a parse tree of the tokens toks.
-
-    EXAMPLES:
+	
+    - Returns a parse tree of the tokens toks.
+   
+    EXAMPLES::
+	
         sage: import sage.logic.logicparser as logicparser
         sage: t = ['a', '|', 'b', '&', 'c']
         sage: logicparser.parse_ltor(t)
         ['|', 'a', ['&', 'b', 'c']]
     """
     i = 0
-    for tok in toks:
+    for tok in toks:        
         if(tok == __op_list[n]):
             if(tok == '~'):
                 #cancel double negations
@@ -171,30 +187,33 @@
                 return parse_ltor(toks, n)
             else:
                 args = [toks[i - 1], toks[i], toks[i + 1]]
-                toks[i - 1] = [args[1], args[0], args[2]]
+                toks[i - 1] = [args[1], args[0], args[2]]   
                 del toks[i]
                 del toks[i]
                 return parse_ltor(toks, n)
         i += 1
-    if(n + 1 < len(__op_list)):
+    if(n + 1 < len(__op_list)):        
         return parse_ltor(toks, n + 1)
     if(len(toks) > 1):
         raise SyntaxError
-    return toks[0]
+    return toks[0]    
 
 def apply_func(tree, func):
     r"""
-    This function applies func to each node of tree.
+    This function applies ``func`` to each node of ``tree``.
 
     INPUT:
-        tree -- a parse tree.
-        func -- a function to be applied to tree.
+	
+    - ``tree`` -- a parse tree.
+    - ``func`` -- a function to be applied to tree.
+    
+    OUTPUT:
+	
+    - Returns a parse tree after func has been applied
+      to it.
 
-    OUTPUT:
-        Returns a parse tree after func has been applied
-        to it.
-
-    EXAMPLES:
+    EXAMPLES::
+	
         sage: import sage.logic.logicparser as logicparser
         sage: t = ['|', ['&', 'a', 'b'], ['&', 'a', 'c']]
         sage: f = lambda t: t
@@ -214,4 +233,3 @@
         lval = tree[1]
         rval = tree[2]
     return func([tree[0], lval, rval])
-
